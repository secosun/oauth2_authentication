<?php
/**
 * @file
 * Provides functionality for the OAuth2 Authentication module.
 */

/**
 * Implements hook_menu().
 */
function oauth2_authentication_menu() {
  $items = array();
  $items['admin/config/services/oauth2-authentication'] = array(
    'title' => 'OAuth2 Authentication',
    'description' => 'Configure OAuth2 Authentication parameters.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('oauth2_authentication_admin_form'),
    'access arguments' => array('administer oauth2 authentication'),
    'file' => 'includes/oauth2_authentication.admin.inc',
  );
  return $items;
}

/**
 * Implements hook_permission().
 */
function oauth2_authentication_permission() {
  return array(
    'administer oauth2 authentication' => array(
      'title' => t('Administer authentication parameters'),
      'description' => t('Allows users to set authentication parameters such as the token endpoint and client credentials.'),
    ),
  );
}

/**
 * Implements hook_form_FORM_ID_alter() for the user_login form.
 *
 * As per user_login_default_validators(), there are three (3) standard
 * validation functions that determine if a user can be logged in.
 *
 *   1. user_login_name_validate()
 *   2. user_login_authenticate_validate()
 *   3. user_login_final_validate()
 *
 * We need to override the second one because it determines the user validity
 * based exclusively on its existence in the database.  In our case, if the user
 * exists as per the remote authorization service, but not locally, we want to
 * create it.
 */
function oauth2_authentication_form_user_login_alter(&$form, &$form_state, $form_id) {

  // Replace the user_login_authenticate_validate() call with our own
  // oauth2_authentication_login_authenticate_validate() function.
  if (in_array('user_login_authenticate_validate', $form['#validate'])) {
    $key = array_search('user_login_authenticate_validate', $form['#validate']);
    $form['#validate'][$key] = 'oauth2_authentication_login_authenticate_validate';
  }
}

/**
 * Implements hook_form_FORM_ID_alter() for the user_login_block form.
 *
 * Make the same changes as we're making to the standard login form.  See
 * oauth2_authentication_form_user_login_alter() for details.
 */
function oauth2_authentication_form_user_login_block_alter(&$form, &$form_state, $form_id) {
  return oauth2_authentication_form_user_login_alter($form, $form_state, $form_id);
}

/**
 * Replacement for user_login_authenticate_validate().
 *
 * All code here except for the last stanza should be identical to what's in
 * user_login_authenticate_validate().  The last stanza is the only thing we'd
 * like to change as that's the function call we actually care about.
 */
function oauth2_authentication_login_authenticate_validate($form, &$form_state) {
  $password = trim($form_state['values']['pass']);
  if (!empty($form_state['values']['name']) && !empty($password)) {
    // Do not allow any login from the current user's IP if the limit has been
    // reached. Default is 50 failed attempts allowed in one hour. This is
    // independent of the per-user limit to catch attempts from one IP to log
    // in to many different user accounts.  We have a reasonably high limit
    // since there may be only one apparent IP for all users at an institution.
    if (!flood_is_allowed('failed_login_attempt_ip', variable_get('user_failed_login_ip_limit', 50), variable_get('user_failed_login_ip_window', 3600))) {
      $form_state['flood_control_triggered'] = 'ip';
      return;
    }
    $account = db_query("SELECT * FROM {users} WHERE name = :name AND status = 1", array(':name' => $form_state['values']['name']))->fetchObject();
    if ($account) {
      if (variable_get('user_failed_login_identifier_uid_only', FALSE)) {
        // Register flood events based on the uid only, so they apply for any
        // IP address. This is the most secure option.
        $identifier = $account->uid;
      }
      else {
        // The default identifier is a combination of uid and IP address. This
        // is less secure but more resistant to denial-of-service attacks that
        // could lock out all users with public user names.
        $identifier = $account->uid . '-' . ip_address();
      }
      $form_state['flood_control_user_identifier'] = $identifier;

      // Don't allow login if the limit for this user has been reached.
      // Default is to allow 5 failed attempts every 6 hours.
      if (!flood_is_allowed('failed_login_attempt_user', variable_get('user_failed_login_user_limit', 5), variable_get('user_failed_login_user_window', 21600), $identifier)) {
        $form_state['flood_control_triggered'] = 'user';
        return;
      }
    }

    // We are not limited by flood control, so try to authenticate.
    // Set $form_state['uid'] as a flag for user_login_final_validate().
    $form_state['uid'] = oauth2_authentication_authenticate($form_state['values']['name'], $password);
  }
}

/**
 * Replacement for user_authenticate().
 *
 * user_authenticate() determines if a user is valid by looking it up in the
 * local database.  If that's not the case, the user may exist in the remote
 * system.  So we want to add him/her locally if he/she exists there.
 *
 * Most of the code here, at the beginning of the function, should mirror
 * user_authenticate().  If that code fails, then we check if the user exists
 * remotely.  If so, add it.
 *
 * @param $name
 *   User name to authenticate.
 * @param $password
 *   A plain-text password, such as trimmed text from form values.
 * @return
 *   The user's uid on success, or FALSE on failure to authenticate.
 *
 * @todo Make the instantiated class configurable.
 */
function oauth2_authentication_authenticate($name, $password) {
  $uid = FALSE;
  if (!empty($name) && !empty($password)) {
    $account = user_load_by_name($name);
    if ($account) {
      // Allow alternate password hashing schemes.
      require_once DRUPAL_ROOT . '/' . variable_get('password_inc', 'includes/password.inc');
      if (user_check_password($password, $account)) {
        // Successful authentication.
        $uid = $account->uid;

        // Update user to new password scheme if needed.
        if (user_needs_new_hash($account)) {
          user_save($account, array('pass' => $password));
        }
      }
    }

    else /* there is no local user account */ {

      // Determine if the user can be authenticated via OAuth2.
      $client = new OAuth2AuthenticationClient($name, $password);
      if ($client->userExistsRemotely()) {

        // We're dealing with a valid remote user so add it here.
        $uid = $client->createUserLocally()->uid;
      }
    }
  }

  // Return the user's local ID if there is one.
  return $uid;
}

/**
 * Determines if a user with a provided name and password exists remotely.
 *
 * @param $name
 *   The username used by the current user to log in.
 * @param $password
 *   The password used by the current user to log in.
 * @return
 *   TRUE if the user exists remotely; FALSE otherwise.
 *
 * @todo Return TRUE if a valid token is returned.
 */
function oauth2_authentication_check_password($name, $password) {

  // Configure the OAuth2 client.
  $oauth2_config = array(
    'auth_flow'      => 'user-password',
    'token_endpoint' => variable_get('oauth2_authentication_token_endpoint', ''),
    'client_id'      => variable_get('oauth2_authentication_client_id', ''),
    'client_secret'  => variable_get('oauth2_authentication_client_secret', ''),
    'scope'          => variable_get('oauth2_authentication_scope', ''),
    'username'       => $name,
    'password'       => $password,
  );

  // Attempt to get an access token.
  try {
    $oauth2_client = new OAuth2\Client($oauth2_config);
    $access_token = $oauth2_client->getAccessToken();
  }
  catch (Exception $e) {
    drupal_set_message($e->getMessage(), 'error');
  }

  // Code goes here.

  return FALSE;
}

/**
 * Create a new user based on the successful validation of a remote user.
 *
 * This function creates a new local Drupal user if a corresponding remote
 * user exists, but doesn't exist here yet.
 *
 * @param $name
 *   The username of the user to be created.
 * @param $password
 *   The password of the user to be created.
 * @return
 *   The user ID of the newly created user.  FALSE is returned if the user could
 *   not be created.
 */
function oauth2_authentication_create_user($name, $password) {

  // Get the user's e-mail address from some remote service.
  $email = oauth2_authentication_get_email($name);

  // Create a list of user information.
  $user = array(
    'name'   => $name,
    'pass'   => $password,
    'mail'   => $email,
    'status' => 1,
    'init'   => $email,
    'roles'  => array(
      DRUPAL_AUTHENTICATED_RID => 'authenticated user',
    ),
  );

  // Save the new user.
  $user = user_save(NULL, $user);

  // Return the user's ID.
  return $user ? $user->uid : FALSE;
}

/**
 * Fetches the e-mail address of the user to be created.
 *
 * @param $name
 *   The user's username.
 * @return
 *   The user's e-mail address.
 *
 * @todo Turn all of these functions into OAuth2AuthenticationClient methods so
 *   that they can be overridden through subclassing.  This one will return the
 *   empty string by default, but in most cases, it will really need to do
 *   something (unless users don't need e-mail addresses, but this seems
 *   unlikely).
 * @todo Add a new configuration option for the class name to instantiate.  By
 *   default, it will be OAuth2AuthenticationClient.
 */
function oauth2_authentication_get_email($name) {
  return '';
}

